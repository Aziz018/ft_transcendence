// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum RoomType {
  DIRECT
  GROUP
}

enum MemberRole {
  OWNER
  ADMIN
  MEMBER
}

enum UserStatus {
  IN_GAME
  OFFLINE
  ONLINE
  BUSY
}


/**
 * Represents the state of a friend request between two users:
 * - PENDING  → The request has been sent but not answered yet
 * - ACCEPTED → The request was accepted, users are now friends
 * - REJECTED → The request was declined
 */
enum FriendRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

/**
 * Represents a system user.
 * Fields:
 * - name      → Unique display name
 * - email     → Unique email address
 * - password  → User's hashed password
 * - createdAt → Timestamp when the user was created
 * - updatedAt → Timestamp of the last update
 * - avatar    → URL or path to the user's avatar image
 * - sentRequests     → Friend requests this user has sent
 * - receivedRequests → Friend requests this user has received
 */
model User {
  id        String   @id @default(uuid())
  name      String   @unique
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  avatar    String   @default("../public/images/default-avatar.jpg")
  xp        Int      @default(0)

  sentRequests     FriendRequest[] @relation("RequestSent")
  receivedRequests FriendRequest[] @relation("RequestReceived")

  blockedUsers   BlockedUser[] @relation("blocker")
  blockedByUsers BlockedUser[] @relation("blocked")

  friendships1 Friendship[] @relation("UserFriendships1")
  friendships2 Friendship[] @relation("UserFriendships2")

  secret        String?
  refreshTokens RefreshToken[]
  status        UserStatus @default(OFFLINE)
  lastSeen      DateTime   @default(now())

  sentMessages      Message[] @relation("MessageSender")
  receivedMessages  Message[] @relation("MessageReceiver")
  rooms             RoomMember[]
  tournaments       TournamentParticipant[]
  


  @@index([name, email])
}

/**
 * Represents a friend request between two users.
 * - requester → The user who sent the request
 * - requested → The user who received the request
 * - status    → Current state of the request (PENDING, ACCEPTED, REJECTED)
 * - timestamp → Auto-set to the time the request was created
 */
model FriendRequest {
  id          String              @id @default(uuid())
  requester   User                @relation("RequestSent", fields: [requesterId], references: [id])
  requested   User                @relation("RequestReceived", fields: [requestedId], references: [id])
  status      FriendRequestStatus @default(PENDING)
  timestamp   DateTime            @default(now())
  requesterId String
  requestedId String
}

/**
 * Stores JWTs that have been invalidated before their natural expiry,
 * - id → Auto-incrementing primary key.
 * - token → The JWT string, must be unique.
 * - expiresAt → Original expiration time of the token.
 * - createdAt → Timestamp when the token was blacklisted.
 */
model BlacklistedToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model BlockedUser {
  id        String   @id @default(uuid())
  blockerId String
  blockedId String
  timestamp DateTime @default(now())
  blocker   User     @relation("blocker", fields: [blockerId], references: [id])
  blocked   User     @relation("blocked", fields: [blockedId], references: [id])

  @@unique([blockerId, blockedId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  token     String   @unique
  isValid   Boolean  @default(true)
  createdAt DateTime @default(now())
  expiredAt DateTime
}
model Room {
  id        String @id @default(uuid())
  name      String?
  type      RoomType @default(GROUP)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages  Message[]
  members   RoomMember[]
}

model RoomMember {
  id        String @id @default(uuid())
  userId    String
  roomId    String
  role      MemberRole @default(MEMBER)
  joinedAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  @@unique([userId, roomId])
}

model Message {
  id          String @id @default(uuid())
  content     String
  senderId    String
  receiverId  String?
  roomId      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  sender    User @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver  User? @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  room      Room? @relation(fields: [roomId], references: [id], onDelete: Cascade)
}

model Friendship {
  id        String   @id @default(uuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())

  user1 User @relation("UserFriendships1", fields: [user1Id], references: [id])
  user2 User @relation("UserFriendships2", fields: [user2Id], references: [id])

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

// Game-related enums and models

enum GameType {
  CLASSIC
  TOURNAMENT
  RANKED
  CASUAL
}

enum GameStatus {
  WAITING
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

/**
 * Represents an individual game session between two players.
 * Stores game state, scores, and timestamps for analytics.
 */
model GameSession {
  id          String      @id @default(uuid())
  gameType    GameType    @default(CLASSIC)
  status      GameStatus  @default(WAITING)

  player1Id   String?
  player2Id   String?
  winnerId    String?

  player1Score Int       @default(0)
  player2Score Int       @default(0)

  player1Exp   Int?      // Final EXP earned
  player2Exp   Int?      // Final EXP earned

  durationMs   Int?      // Match duration in milliseconds

  createdAt    DateTime  @default(now())
  startedAt    DateTime?
  completedAt  DateTime?

  @@index([status, createdAt])
  @@index([player1Id, player2Id])
  @@index([winnerId])
}

/**
 * Stores player statistics and analytics.
 * Aggregates performance metrics across all games.
 */
model PlayerStats {
  id              String   @id @default(uuid())
  userId          String   @unique

  totalGames      Int      @default(0)
  totalWins       Int      @default(0)
  totalLosses     Int      @default(0)
  totalDraws      Int      @default(0)

  winStreak       Int      @default(0)
  bestWinStreak   Int      @default(0)

  totalExpEarned  Int      @default(0)
  averageGameDuration Int  @default(0)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([totalWins, totalGames])
}

/**
 * Stores historical game records for leaderboard and analytics.
 * Optimized for quick querying of recent games and player performance.
 */
model GameHistory {
  id            String   @id @default(uuid())
  gameSessionId String   @unique
  gameType      GameType

  player1Id     String
  player2Id     String
  winnerId      String?

  player1Name   String
  player2Name   String

  player1Score  Int
  player2Score  Int

  durationMs    Int
  playedAt      DateTime @default(now())

  @@index([playedAt])
  @@index([player1Id, playedAt])
  @@index([player2Id, playedAt])
  @@index([winnerId, playedAt])
}

enum TournamentStatus {
  PENDING
  ONGOING
  FINISHED
}

model Tournament {
  id             String                @id @default(uuid())
  name           String
  status         TournamentStatus      @default(PENDING)
  creatorId      String
  maxPlayers     Int                   @default(8)
  currentPlayers Int                   @default(0)
  prize          String?
  startDate      DateTime              @default(now())
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt

  participants   TournamentParticipant[]
}

model TournamentParticipant {
  id           String     @id @default(uuid())
  tournamentId String
  userId       String
  score        Int        @default(0)
  joinedAt     DateTime   @default(now())

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, userId])
}
